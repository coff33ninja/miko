<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Anime AI Character - Live2D Interactive Experience</title>

    <!-- Live2D Cubism SDK -->
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.3.12/pixi.min.js"></script>
    <script defer src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/cubism4.min.js"></script>

    <!-- LiveKit SDK -->
    <script defer src="/static/js/livekit-client.umd.js"></script>

    <!-- Animation System Scripts -->
    <script defer src="/static/js/live2d-parameter-mapping.js"></script>
    <script defer src="/static/js/live2d-integration.js"></script>
    <script defer src="/static/js/animation-controller.js"></script>
    <script defer src="/static/js/websocket-animation-client.js"></script>
    <script defer src="/static/js/animation-tests.js"></script>
    <script defer src="/static/js/web-interface-tests.js"></script>

    <style>
      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 0;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        overflow: hidden;
      }

      .container {
        display: flex;
        height: 100vh;
        width: 100vw;
        position: relative;
      }

      .live2d-container {
        flex: 1;
        position: relative;
        z-index: 1;
        background: rgba(0, 0, 0, 0.2);
        margin: 10px;
        border-radius: 10px;
        z-index: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        min-width: 0;
      }

      #live2d-canvas {
        max-width: 100%;
        max-height: 100%;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        background: rgba(255, 255, 255, 0.1);
      }

      .control-panel {
        width: 320px;
        background: rgba(0, 0, 0, 0.85);
        padding: 15px;
        box-sizing: border-box;
        overflow-y: auto;
        border-left: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
      }

      /* Mobile-first responsive design */
      @media (max-width: 768px) {
        .container {
          flex-direction: column;
        }
        
        .control-panel {
          width: 100%;
          height: 40vh;
          border-left: none;
          border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .live2d-container {
          height: 60vh;
        }
        
        .control-section {
          margin-bottom: 15px !important;
          padding: 10px !important;
        }
        
        .animation-controls {
          grid-template-columns: repeat(3, 1fr) !important;
        }
      }

      @media (max-width: 480px) {
        .control-panel {
          height: 50vh;
          padding: 10px;
        }
        
        .live2d-container {
          height: 50vh;
        }
        
        .animation-controls {
          grid-template-columns: repeat(2, 1fr) !important;
        }
        
        .button {
          padding: 8px !important;
          font-size: 12px !important;
        }
      }

      /* Tablet landscape */
      @media (min-width: 769px) and (max-width: 1024px) {
        .control-panel {
          width: 280px;
        }
      }

      /* Large screens */
      @media (min-width: 1200px) {
        .control-panel {
          width: 350px;
        }
      }

      .control-section {
        margin-bottom: 20px;
        padding: 15px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
      }

      .control-section h3 {
        margin: 0 0 10px 0;
        color: #fff;
        font-size: 16px;
      }

      .button {
        width: 100%;
        padding: 10px;
        margin: 5px 0;
        background: #667eea;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.3s;
      }

      .button:hover {
        background: #5a6fd8;
      }

      .button:disabled {
        background: #666;
        cursor: not-allowed;
      }

      .status {
        padding: 10px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 5px;
        font-size: 12px;
        margin: 10px 0;
      }

      .status.connected {
        background: rgba(0, 128, 0, 0.3);
      }

      .status.error {
        background: rgba(128, 0, 0, 0.3);
      }

      .animation-controls {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 5px;
      }

      .slider-container {
        margin: 10px 0;
      }

      .slider-container label {
        display: block;
        margin-bottom: 5px;
        font-size: 12px;
      }

      .slider {
        width: 100%;
        margin: 5px 0;
      }

      #chat-messages {
        height: 200px;
        overflow-y: auto;
        background: rgba(0, 0, 0, 0.3);
        padding: 10px;
        border-radius: 5px;
        font-size: 12px;
        margin: 10px 0;
      }

      .message {
        margin: 5px 0;
        padding: 5px;
        border-radius: 3px;
      }

      .message.user {
        background: rgba(102, 126, 234, 0.3);
        text-align: right;
      }

      .message.ai {
        background: rgba(118, 75, 162, 0.3);
      }

      .loading {
        display: none;
        text-align: center;
        padding: 20px;
      }

      .spinner {
        border: 2px solid #f3f3f3;
        border-top: 2px solid #667eea;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        animation: spin 1s linear infinite;
        margin: 0 auto;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Input Controls Styles */
      .input-mode-toggle {
        display: flex;
        gap: 5px;
        margin-bottom: 15px;
      }

      .mode-button {
        flex: 1;
        padding: 8px;
        font-size: 12px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .mode-button.active {
        background: #667eea;
        border-color: #667eea;
      }

      .input-controls {
        margin-top: 10px;
      }

      .text-input-container {
        margin-bottom: 10px;
      }

      #text-input {
        width: 100%;
        padding: 10px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 5px;
        background: rgba(0, 0, 0, 0.3);
        color: white;
        font-family: inherit;
        resize: vertical;
        min-height: 60px;
      }

      #text-input::placeholder {
        color: rgba(255, 255, 255, 0.5);
      }

      #text-input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 5px rgba(102, 126, 234, 0.3);
      }

      .quick-messages {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        margin-top: 10px;
      }

      .quick-msg {
        flex: 1;
        min-width: calc(50% - 2.5px);
        padding: 6px;
        font-size: 11px;
        background: rgba(118, 75, 162, 0.6);
      }

      .quick-msg:hover {
        background: rgba(118, 75, 162, 0.8);
      }

      .audio-level-container {
        margin: 10px 0;
      }

      .audio-level-container label {
        display: block;
        font-size: 12px;
        margin-bottom: 5px;
      }

      .audio-level-bar {
        width: 100%;
        height: 8px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 4px;
        overflow: hidden;
      }

      #audio-level-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722);
        transition: width 0.1s ease;
      }

      /* Push to talk button special styling */
      #push-to-talk-btn {
        background: rgba(255, 87, 34, 0.8);
        border: 2px solid transparent;
      }

      #push-to-talk-btn:hover {
        background: rgba(255, 87, 34, 1);
      }

      #push-to-talk-btn.active {
        background: #FF5722;
        border-color: #FF8A65;
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(255, 87, 34, 0.7); }
        70% { box-shadow: 0 0 0 10px rgba(255, 87, 34, 0); }
        100% { box-shadow: 0 0 0 0 rgba(255, 87, 34, 0); }
      }

      /* Participant list styles */
      .participants-list {
        max-height: 120px;
        overflow-y: auto;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 5px;
        padding: 5px;
        margin: 10px 0;
      }

      .participant-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 5px;
        margin: 2px 0;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
        font-size: 12px;
      }

      .participant-status {
        display: flex;
        gap: 5px;
      }

      .status-indicator {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #666;
      }

      .status-indicator.speaking {
        background: #4CAF50;
        animation: pulse 0.5s infinite;
      }

      .status-indicator.muted {
        background: #FF5722;
      }

      /* Connection quality indicator */
      .connection-quality {
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 11px;
        margin: 5px 0;
      }

      .quality-bars {
        display: flex;
        gap: 1px;
      }

      .quality-bar {
        width: 3px;
        height: 8px;
        background: #666;
        border-radius: 1px;
      }

      .quality-bar.active {
        background: #4CAF50;
      }

      .quality-bar.medium {
        background: #FFC107;
      }

      .quality-bar.poor {
        background: #FF5722;
      }

      /* Button grouping */
      .button-group {
        display: flex;
        gap: 5px;
        margin: 10px 0;
      }

      .button-group .button {
        flex: 1;
        margin: 0;
      }

      /* Test section styling */
      .test-controls {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 5px;
        margin: 10px 0;
      }

      .test-controls .button {
        font-size: 11px;
        padding: 6px;
      }

      /* Loading states */
      .button.loading {
        opacity: 0.6;
        cursor: not-allowed;
        position: relative;
      }

      .button.loading::after {
        content: '';
        position: absolute;
        top: 50%;
        right: 8px;
        width: 12px;
        height: 12px;
        margin-top: -6px;
        border: 2px solid transparent;
        border-top: 2px solid currentColor;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      /* Success/error states */
      .status.success {
        background: rgba(76, 175, 80, 0.3);
        border-left: 3px solid #4CAF50;
      }

      .status.warning {
        background: rgba(255, 193, 7, 0.3);
        border-left: 3px solid #FFC107;
      }

      /* Accessibility improvements */
      .button:focus {
        outline: 2px solid #667eea;
        outline-offset: 2px;
      }

      .slider:focus {
        outline: 2px solid #667eea;
        outline-offset: 2px;
      }

      /* High contrast mode support */
      @media (prefers-contrast: high) {
        .button {
          border: 2px solid white;
        }
        
        .status {
          border: 1px solid white;
        }
      }

      /* Reduced motion support */
      @media (prefers-reduced-motion: reduce) {
        .spinner,
        .button.loading::after,
        #audio-level-fill {
          animation: none;
        }
        
        .button,
        .status {
          transition: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="live2d-container">
        <canvas id="live2d-canvas" width="800" height="600"></canvas>
        <div class="loading" id="loading">
          <div class="spinner"></div>
          <p>Loading Live2D model...</p>
        </div>
      </div>

      <div class="control-panel">
        <div class="control-section">
          <h3>Connection Status</h3>
          <div id="connection-status" class="status">Disconnected</div>
          <div class="connection-quality">
            <span>Quality:</span>
            <div class="quality-bars">
              <div class="quality-bar"></div>
              <div class="quality-bar"></div>
              <div class="quality-bar"></div>
              <div class="quality-bar"></div>
            </div>
            <span id="quality-text">Unknown</span>
          </div>
          
          <div class="button-group">
            <button id="connect-btn" class="button">üîó Connect to LiveKit</button>
            <button id="disconnect-btn" class="button" disabled>‚ùå Disconnect</button>
          </div>

          <h4 style="margin-top: 15px; margin-bottom: 5px; font-size: 14px">
            Room Participants
          </h4>
          <div id="participants-list" class="participants-list">
            <div class="participant-item">
              <span>No participants</span>
            </div>
          </div>

          <h4 style="margin-top: 15px; margin-bottom: 5px; font-size: 14px">
            WebSocket Status
          </h4>
          <div id="websocket-status" class="status">Connecting...</div>
          <button id="websocket-reconnect" class="button" onclick="reconnectWebSocket()">
            üîÑ Reconnect WebSocket
          </button>
        </div>

        <div class="control-section">
          <h3>Input Controls</h3>
          
          <!-- Input Mode Toggle -->
          <div class="input-mode-toggle">
            <button id="voice-mode-btn" class="button mode-button active">üé§ Voice Mode</button>
            <button id="text-mode-btn" class="button mode-button">üí¨ Text Mode</button>
          </div>
          
          <!-- Voice Controls -->
          <div id="voice-controls" class="input-controls">
            <button id="mic-btn" class="button" disabled>üé§ Start Talking</button>
            <button id="push-to-talk-btn" class="button" disabled>üì¢ Push to Talk</button>
            <div id="voice-status" class="status">Voice inactive</div>
            <div class="audio-level-container">
              <label>Audio Level:</label>
              <div class="audio-level-bar">
                <div id="audio-level-fill"></div>
              </div>
            </div>
          </div>
          
          <!-- Text Controls -->
          <div id="text-controls" class="input-controls" style="display: none;">
            <div class="text-input-container">
              <textarea id="text-input" placeholder="Type your message here..." rows="3"></textarea>
              <button id="send-text-btn" class="button">üì§ Send Message</button>
            </div>
            <div class="quick-messages">
              <button class="button quick-msg" data-msg="Hello! How are you today?">üëã Greeting</button>
              <button class="button quick-msg" data-msg="Tell me a joke!">üòÑ Joke</button>
              <button class="button quick-msg" data-msg="What's your favorite anime?">üéå Anime</button>
            </div>
          </div>
        </div>

        <div class="control-section">
          <h3>Animation Controls</h3>
          <div class="animation-controls">
            <button class="button" onclick="triggerAnimation('happy')">
              üòä Happy
            </button>
            <button class="button" onclick="triggerAnimation('sad')">
              üò¢ Sad
            </button>
            <button class="button" onclick="triggerAnimation('surprised')">
              üò≤ Surprised
            </button>
            <button class="button" onclick="triggerAnimation('angry')">
              üò† Angry
            </button>
            <button class="button" onclick="triggerAnimation('neutral')">
              üòê Neutral
            </button>
            <button class="button" onclick="triggerAnimation('speak')">
              üó£Ô∏è Speaking
            </button>
          </div>

          <div class="animation-controls">
            <button class="button" onclick="triggerAnimation('blink')">
              üòâ Blink
            </button>
            <button class="button" onclick="triggerAnimation('wink_left')">
              üòâ Wink L
            </button>
            <button class="button" onclick="triggerAnimation('wink_right')">
              üòâ Wink R
            </button>
            <button class="button" onclick="testMouthSync()">
              üéµ Mouth Test
            </button>
          </div>

          <div class="slider-container">
            <label for="intensity-slider">Animation Intensity:</label>
            <input
              type="range"
              id="intensity-slider"
              class="slider"
              min="0"
              max="1"
              step="0.1"
              value="0.7"
            />
            <span id="intensity-value">0.7</span>
          </div>

          <div class="slider-container">
            <label for="duration-slider">Duration (seconds):</label>
            <input
              type="range"
              id="duration-slider"
              class="slider"
              min="0.5"
              max="5"
              step="0.5"
              value="2"
            />
            <span id="duration-value">2.0</span>
          </div>

          <div class="test-controls">
            <button class="button" onclick="runAnimationTests()">
              üß™ Animation Tests
            </button>
            <button class="button" onclick="runWebInterfaceTests()">
              üî¨ Interface Tests
            </button>
          </div>
          <button class="button" onclick="resetAnimation()">üîÑ Reset Animation</button>
        </div>

        <div class="control-section">
          <h3>Chat History</h3>
          <div id="chat-messages"></div>
          <button id="clear-chat" class="button">Clear Chat</button>
        </div>

        <div class="control-section">
          <h3>System Info</h3>
          <div id="system-status" class="status">
            <div>Model: {{ model_url or 'Not configured' }}</div>
            <div>LiveKit: {{ livekit_url or 'Not configured' }}</div>
            <div id="websocket-info">WebSocket: Initializing...</div>
            <div id="server-info">Server: Unknown</div>
          </div>
        </div>

        <div class="control-section">
          <h3>Real-time Sync</h3>
          <button class="button" onclick="testTTSSync()">
            üéµ Test TTS Sync
          </button>
          <button class="button" onclick="testMouthSyncRealtime()">
            üëÑ Test Mouth Sync
          </button>
          <button class="button" onclick="testAnimationQueue()">
            üìã Test Queue
          </button>
          <button class="button" onclick="requestServerAnimation()">
            üåê Server Animation
          </button>

          <div class="slider-container">
            <label for="sync-delay-slider">Sync Delay (ms):</label>
            <input
              type="range"
              id="sync-delay-slider"
              class="slider"
              min="0"
              max="500"
              step="10"
              value="100"
            />
            <span id="sync-delay-value">100</span>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Global variables
      let room = null;
      let isConnected = false;
      let isMicActive = false;
      let live2dIntegration = null;
      let animationController = null;
      let parameterMapping = null;
      let websocketClient = null;

      // Configuration from Flask template
      const LIVEKIT_URL = "{{ livekit_url }}";
      const MODEL_URL = "{{ model_url }}";

      // DOM elements
      const connectBtn = document.getElementById("connect-btn");
      const disconnectBtn = document.getElementById("disconnect-btn");
      const micBtn = document.getElementById("mic-btn");
      const pushToTalkBtn = document.getElementById("push-to-talk-btn");
      const connectionStatus = document.getElementById("connection-status");
      const voiceStatus = document.getElementById("voice-status");
      const chatMessages = document.getElementById("chat-messages");
      const intensitySlider = document.getElementById("intensity-slider");
      const durationSlider = document.getElementById("duration-slider");
      const intensityValue = document.getElementById("intensity-value");
      const durationValue = document.getElementById("duration-value");
      
      // Input mode elements
      const voiceModeBtn = document.getElementById("voice-mode-btn");
      const textModeBtn = document.getElementById("text-mode-btn");
      const voiceControls = document.getElementById("voice-controls");
      const textControls = document.getElementById("text-controls");
      const textInput = document.getElementById("text-input");
      const sendTextBtn = document.getElementById("send-text-btn");
      const participantsList = document.getElementById("participants-list");
      const audioLevelFill = document.getElementById("audio-level-fill");
      
      // State variables
      let currentInputMode = 'voice';
      let isPushToTalkActive = false;
      let participants = new Map();
      let connectionQuality = 'unknown';
      let audioLevel = 0;

      // Initialize application
      document.addEventListener("DOMContentLoaded", function () {
        initializeAnimationSystem();
        setupEventListeners();
        updateSliderValues();
      });

      function setupEventListeners() {
        connectBtn.addEventListener("click", connectToLiveKit);
        disconnectBtn.addEventListener("click", disconnectFromLiveKit);
        micBtn.addEventListener("click", toggleMicrophone);

        intensitySlider.addEventListener("input", updateSliderValues);
        durationSlider.addEventListener("input", updateSliderValues);

        document.getElementById("clear-chat").addEventListener("click", clearChat);

        // Input mode switching
        voiceModeBtn.addEventListener("click", () => switchInputMode('voice'));
        textModeBtn.addEventListener("click", () => switchInputMode('text'));
        
        // Text input controls
        sendTextBtn.addEventListener("click", sendTextMessage);
        textInput.addEventListener("keypress", (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendTextMessage();
          }
        });
        
        // Quick message buttons
        document.querySelectorAll('.quick-msg').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const message = e.target.dataset.msg;
            textInput.value = message;
            sendTextMessage();
          });
        });
        
        // Push to talk
        pushToTalkBtn.addEventListener("mousedown", startPushToTalk);
        pushToTalkBtn.addEventListener("mouseup", stopPushToTalk);
        pushToTalkBtn.addEventListener("mouseleave", stopPushToTalk);
        
        // Keyboard shortcuts
        document.addEventListener("keydown", handleKeyboardShortcuts);

        // WebSocket sync delay slider
        const syncDelaySlider = document.getElementById("sync-delay-slider");
        const syncDelayValue = document.getElementById("sync-delay-value");
        if (syncDelaySlider && syncDelayValue) {
          syncDelaySlider.addEventListener("input", () => {
            syncDelayValue.textContent = syncDelaySlider.value;
          });
        }
      }

      function updateSliderValues() {
        intensityValue.textContent = intensitySlider.value;
        durationValue.textContent = durationSlider.value;
      }

      function switchInputMode(mode) {
        currentInputMode = mode;
        
        if (mode === 'voice') {
          voiceModeBtn.classList.add('active');
          textModeBtn.classList.remove('active');
          voiceControls.style.display = 'block';
          textControls.style.display = 'none';
        } else {
          textModeBtn.classList.add('active');
          voiceModeBtn.classList.remove('active');
          textControls.style.display = 'block';
          voiceControls.style.display = 'none';
          textInput.focus();
        }
        
        addChatMessage("system", `Switched to ${mode} input mode`);
      }

      async function sendTextMessage() {
        const message = textInput.value.trim();
        if (!message) return;
        
        if (!isConnected) {
          addChatMessage("system", "Not connected to LiveKit room");
          return;
        }
        
        try {
          // Add user message to chat
          addChatMessage("user", message);
          
          // Send message to LiveKit room
          const encoder = new TextEncoder();
          const data = encoder.encode(JSON.stringify({
            type: 'text_message',
            message: message,
            timestamp: Date.now()
          }));
          
          await room.localParticipant.publishData(data, LivekitClient.DataPacket_Kind.RELIABLE);
          
          // Clear input
          textInput.value = '';
          
          // Trigger speaking animation
          triggerAnimation('speak', 0.6, 2.0);
          
        } catch (error) {
          console.error("Failed to send text message:", error);
          addChatMessage("system", "Failed to send message: " + error.message);
        }
      }

      function startPushToTalk() {
        if (!isConnected || isPushToTalkActive) return;
        
        isPushToTalkActive = true;
        pushToTalkBtn.classList.add('active');
        pushToTalkBtn.textContent = 'üî¥ Recording...';
        
        // Enable microphone
        room.localParticipant.setMicrophoneEnabled(true);
        voiceStatus.textContent = "Push-to-talk active";
        voiceStatus.className = "status connected";
        
        addChatMessage("system", "Push-to-talk started");
      }

      function stopPushToTalk() {
        if (!isPushToTalkActive) return;
        
        isPushToTalkActive = false;
        pushToTalkBtn.classList.remove('active');
        pushToTalkBtn.textContent = 'üì¢ Push to Talk';
        
        // Disable microphone
        room.localParticipant.setMicrophoneEnabled(false);
        voiceStatus.textContent = "Push-to-talk inactive";
        voiceStatus.className = "status";
        
        addChatMessage("system", "Push-to-talk stopped");
      }

      function handleKeyboardShortcuts(event) {
        // Space bar for push-to-talk (when not typing in text input)
        if (event.code === 'Space' && currentInputMode === 'voice' && 
            document.activeElement !== textInput) {
          event.preventDefault();
          if (event.type === 'keydown' && !isPushToTalkActive) {
            startPushToTalk();
          }
        }
        
        // Ctrl+Enter to send text message
        if (event.ctrlKey && event.key === 'Enter' && currentInputMode === 'text') {
          sendTextMessage();
        }
        
        // Tab to switch input modes
        if (event.key === 'Tab' && event.ctrlKey) {
          event.preventDefault();
          switchInputMode(currentInputMode === 'voice' ? 'text' : 'voice');
        }
      }

      // Handle space bar release for push-to-talk
      document.addEventListener("keyup", (event) => {
        if (event.code === 'Space' && isPushToTalkActive) {
          stopPushToTalk();
        }
      });

      function updateParticipantsList() {
        if (!participantsList) return;
        
        participantsList.innerHTML = '';
        
        if (participants.size === 0) {
          const noParticipants = document.createElement('div');
          noParticipants.className = 'participant-item';
          noParticipants.innerHTML = '<span>No participants</span>';
          participantsList.appendChild(noParticipants);
          return;
        }
        
        participants.forEach((participant, id) => {
          const item = document.createElement('div');
          item.className = 'participant-item';
          
          const name = participant.identity || `User ${id.slice(-4)}`;
          const isLocal = participant.isLocal;
          const isSpeaking = participant.isSpeaking || false;
          const isMuted = !participant.isMicrophoneEnabled;
          
          item.innerHTML = `
            <span>${name}${isLocal ? ' (You)' : ''}</span>
            <div class="participant-status">
              <div class="status-indicator ${isSpeaking ? 'speaking' : ''} ${isMuted ? 'muted' : ''}"></div>
            </div>
          `;
          
          participantsList.appendChild(item);
        });
      }

      function updateConnectionQuality(quality) {
        connectionQuality = quality;
        const qualityBars = document.querySelectorAll('.quality-bar');
        const qualityText = document.getElementById('quality-text');
        
        // Reset all bars
        qualityBars.forEach(bar => {
          bar.classList.remove('active', 'medium', 'poor');
        });
        
        let barsToFill = 0;
        let qualityClass = '';
        
        switch (quality) {
          case 'excellent':
            barsToFill = 4;
            qualityClass = 'active';
            qualityText.textContent = 'Excellent';
            break;
          case 'good':
            barsToFill = 3;
            qualityClass = 'active';
            qualityText.textContent = 'Good';
            break;
          case 'poor':
            barsToFill = 2;
            qualityClass = 'medium';
            qualityText.textContent = 'Poor';
            break;
          case 'bad':
            barsToFill = 1;
            qualityClass = 'poor';
            qualityText.textContent = 'Bad';
            break;
          default:
            qualityText.textContent = 'Unknown';
        }
        
        for (let i = 0; i < barsToFill; i++) {
          qualityBars[i].classList.add(qualityClass);
        }
      }

      function updateAudioLevel(level) {
        audioLevel = level;
        if (audioLevelFill) {
          audioLevelFill.style.width = `${level * 100}%`;
        }
      }

      async function initializeAnimationSystem() {
        const canvas = document.getElementById("live2d-canvas");
        const loading = document.getElementById("loading");

        try {
          loading.style.display = "block";
          addChatMessage("system", "Initializing animation system...");

          // Initialize parameter mapping
          parameterMapping = new Live2DParameterMapping();
          console.log("Parameter mapping initialized");

          // Initialize Live2D integration
          live2dIntegration = new Live2DIntegration("live2d-canvas", MODEL_URL);
          console.log("Live2D integration initialized");

          // Wait for Live2D to initialize
          await new Promise((resolve) => setTimeout(resolve, 2000));

          // Initialize animation controller
          animationController = new AnimationController(live2dIntegration);
          console.log("Animation controller initialized");

          // Initialize WebSocket animation client
          websocketClient = new WebSocketAnimationClient(
            live2dIntegration,
            animationController
          );
          console.log("WebSocket animation client initialized");

          // Set up animation event listeners
          setupAnimationEventListeners();

          loading.style.display = "none";
          addChatMessage("system", "Animation system ready!");

          // Test animation
          setTimeout(() => {
            triggerAnimation("happy");
          }, 1000);
        } catch (error) {
          console.error("Failed to initialize animation system:", error);
          loading.style.display = "none";
          addChatMessage(
            "system",
            "Failed to initialize animation system: " + error.message
          );
        }
      }

      function setupAnimationEventListeners() {
        // Listen for AI responses
        document.addEventListener("aiResponseReceived", (event) => {
          addChatMessage("ai", event.detail.text);
        });

        // Listen for user input
        document.addEventListener("userInputReceived", (event) => {
          addChatMessage("user", event.detail.text);
        });

        // Listen for WebSocket events
        document.addEventListener("websocketConnected", (event) => {
          addChatMessage(
            "system",
            `WebSocket connected: ${event.detail.clientId}`
          );
          updateWebSocketStatus("Connected", "connected");
        });

        document.addEventListener("websocketDisconnected", (event) => {
          addChatMessage("system", "WebSocket disconnected");
          updateWebSocketStatus("Disconnected", "error");
        });

        document.addEventListener("websocketError", (event) => {
          addChatMessage("system", `WebSocket error: ${event.detail.error}`);
          updateWebSocketStatus("Error", "error");
        });

        document.addEventListener("audioSyncReady", (event) => {
          addChatMessage("system", "Audio synchronization ready");
          console.log("Audio sync timing:", event.detail);
        });

        document.addEventListener("serverHeartbeat", (event) => {
          console.log("Server heartbeat:", event.detail);
          updateServerStatus(event.detail);
        });
      }

      async function connectToLiveKit() {
        try {
          updateConnectionStatus("Connecting...", "status");

          // Generate token
          const response = await fetch("/token", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              room: "anime-character-room",
              participant: "user-" + Date.now(),
            }),
          });

          if (!response.ok) {
            throw new Error("Failed to generate token");
          }

          const tokenData = await response.json();

          // Connect to LiveKit room
          room = new LivekitClient.Room();

          room.on(LivekitClient.RoomEvent.Connected, () => {
            isConnected = true;
            updateConnectionStatus("Connected", "connected");
            connectBtn.disabled = true;
            disconnectBtn.disabled = false;
            micBtn.disabled = false;
            pushToTalkBtn.disabled = false;
            addChatMessage("system", "Connected to LiveKit room");
            
            // Add local participant
            participants.set(room.localParticipant.sid, {
              identity: room.localParticipant.identity,
              isLocal: true,
              isSpeaking: false,
              isMicrophoneEnabled: false
            });
            updateParticipantsList();
          });

          room.on(LivekitClient.RoomEvent.Disconnected, () => {
            isConnected = false;
            updateConnectionStatus("Disconnected", "status");
            connectBtn.disabled = false;
            disconnectBtn.disabled = true;
            micBtn.disabled = true;
            pushToTalkBtn.disabled = true;
            participants.clear();
            updateParticipantsList();
            addChatMessage("system", "Disconnected from LiveKit room");
          });

          room.on(LivekitClient.RoomEvent.ParticipantConnected, (participant) => {
            participants.set(participant.sid, {
              identity: participant.identity,
              isLocal: false,
              isSpeaking: false,
              isMicrophoneEnabled: participant.isMicrophoneEnabled
            });
            updateParticipantsList();
            addChatMessage("system", `${participant.identity} joined the room`);
          });

          room.on(LivekitClient.RoomEvent.ParticipantDisconnected, (participant) => {
            participants.delete(participant.sid);
            updateParticipantsList();
            addChatMessage("system", `${participant.identity} left the room`);
          });

          room.on(LivekitClient.RoomEvent.ActiveSpeakersChanged, (speakers) => {
            // Reset all speaking states
            participants.forEach(p => p.isSpeaking = false);
            
            // Set speaking state for active speakers
            speakers.forEach(speaker => {
              const participant = participants.get(speaker.sid);
              if (participant) {
                participant.isSpeaking = true;
              }
            });
            updateParticipantsList();
          });

          room.on(LivekitClient.RoomEvent.AudioPlaybackStatusChanged, () => {
            updateConnectionQuality(room.engine.connectionQuality);
          });

          room.on(LivekitClient.RoomEvent.DataReceived, (payload, participant) => {
            try {
              const data = JSON.parse(new TextDecoder().decode(payload));
              
              if (data.type === 'text_message') {
                addChatMessage("ai", data.message);
                // Trigger appropriate animation based on message sentiment
                triggerAnimation('speak', 0.7, 2.0);
              } else if (data.type === 'ai_response') {
                addChatMessage("ai", data.message);
                // Trigger animation based on sentiment
                const sentiment = data.sentiment || 'neutral';
                triggerAnimation(sentiment, data.intensity || 0.7, data.duration || 2.0);
              }
            } catch (error) {
              // Fallback for plain text messages
              const message = new TextDecoder().decode(payload);
              addChatMessage("ai", message);
            }
          });

          room.on(LivekitClient.RoomEvent.LocalTrackPublished, (publication, participant) => {
            if (publication.kind === LivekitClient.Track.Kind.Audio) {
              const participant_data = participants.get(participant.sid);
              if (participant_data) {
                participant_data.isMicrophoneEnabled = true;
                updateParticipantsList();
              }
            }
          });

          room.on(LivekitClient.RoomEvent.LocalTrackUnpublished, (publication, participant) => {
            if (publication.kind === LivekitClient.Track.Kind.Audio) {
              const participant_data = participants.get(participant.sid);
              if (participant_data) {
                participant_data.isMicrophoneEnabled = false;
                updateParticipantsList();
              }
            }
          });

          await room.connect(tokenData.url, tokenData.token);
        } catch (error) {
          console.error("Connection failed:", error);
          updateConnectionStatus(
            "Connection failed: " + error.message,
            "error"
          );
          addChatMessage("system", "Connection failed: " + error.message);
        }
      }

      async function disconnectFromLiveKit() {
        if (room) {
          await room.disconnect();
          room = null;
        }
      }

      async function toggleMicrophone() {
        if (!isConnected) return;

        try {
          if (!isMicActive) {
            // Start microphone
            await room.localParticipant.enableCameraAndMicrophone();
            isMicActive = true;
            micBtn.textContent = "üîá Stop Talking";
            voiceStatus.textContent = "Voice active - listening...";
            voiceStatus.className = "status connected";
          } else {
            // Stop microphone
            await room.localParticipant.setMicrophoneEnabled(false);
            isMicActive = false;
            micBtn.textContent = "üé§ Start Talking";
            voiceStatus.textContent = "Voice inactive";
            voiceStatus.className = "status";
          }
        } catch (error) {
          console.error("Microphone toggle failed:", error);
          addChatMessage("system", "Microphone error: " + error.message);
        }
      }

      async function triggerAnimation(expression) {
        try {
          const intensity = parseFloat(intensitySlider.value);
          const duration = parseFloat(durationSlider.value);

          // Trigger animation via Flask API
          const response = await fetch("/animate", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              expression: expression,
              intensity: intensity,
              duration: duration,
            }),
          });

          if (!response.ok) {
            throw new Error("Animation request failed");
          }

          const result = await response.json();
          console.log("Animation triggered via API:", result);

          // Trigger animation via Live2D integration
          if (live2dIntegration) {
            await live2dIntegration.triggerAnimation(
              expression,
              intensity,
              duration
            );
            addChatMessage(
              "system",
              `Animation: ${expression} (${intensity}, ${duration}s)`
            );
          } else {
            // Fallback to simple visual feedback
            animateLive2DModel(expression, intensity, duration);
            addChatMessage(
              "system",
              `Animation (fallback): ${expression} (${intensity}, ${duration}s)`
            );
          }
        } catch (error) {
          console.error("Animation failed:", error);
          addChatMessage("system", "Animation failed: " + error.message);
        }
      }

      function animateLive2DModel(expression, intensity, duration) {
        // Placeholder for Live2D animation
        // In a real implementation, this would control Live2D model parameters
        console.log(
          `Animating Live2D: ${expression} with intensity ${intensity} for ${duration}s`
        );

        // Visual feedback on canvas
        const canvas = document.getElementById("live2d-canvas");
        const ctx = canvas.getContext("2d");

        // Simple visual feedback
        ctx.fillStyle = getExpressionColor(expression);
        ctx.globalAlpha = intensity;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Fade out animation
        setTimeout(() => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.globalAlpha = 1.0;
        }, duration * 1000);
      }

      function getExpressionColor(expression) {
        const colors = {
          happy: "rgba(255, 255, 0, 0.3)",
          sad: "rgba(0, 0, 255, 0.3)",
          angry: "rgba(255, 0, 0, 0.3)",
          surprised: "rgba(255, 165, 0, 0.3)",
          neutral: "rgba(128, 128, 128, 0.3)",
          speak: "rgba(0, 255, 0, 0.3)",
        };
        return colors[expression] || "rgba(128, 128, 128, 0.3)";
      }

      function updateConnectionStatus(message, className) {
        connectionStatus.textContent = message;
        connectionStatus.className = "status " + (className || "");
      }

      function addChatMessage(type, message) {
        const messageDiv = document.createElement("div");
        messageDiv.className = "message " + type;
        messageDiv.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      function clearChat() {
        chatMessages.innerHTML = "";
      }

      async function testMouthSync() {
        if (!live2dIntegration) {
          addChatMessage("system", "Live2D integration not ready");
          return;
        }

        try {
          // Create a mock audio element for testing
          const mockAudio = document.createElement("audio");
          mockAudio.src =
            "data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT";

          // Simulate TTS start
          document.dispatchEvent(
            new CustomEvent("ttsStarted", {
              detail: { audioElement: mockAudio },
            })
          );

          addChatMessage("system", "Testing mouth synchronization...");

          // Stop after 3 seconds
          setTimeout(() => {
            document.dispatchEvent(new CustomEvent("ttsEnded"));
            addChatMessage("system", "Mouth sync test completed");
          }, 3000);
        } catch (error) {
          console.error("Mouth sync test failed:", error);
          addChatMessage("system", "Mouth sync test failed: " + error.message);
        }
      }

      async function runAnimationTests() {
        if (!window.AnimationTestSuite) {
          addChatMessage("system", "Animation test suite not available");
          return;
        }

        addChatMessage("system", "Running animation tests...");

        try {
          const testSuite = new AnimationTestSuite();
          const results = await testSuite.runAllTests();

          const passed = results.filter((r) => r.passed).length;
          const total = results.length;

          addChatMessage(
            "system",
            `Animation tests completed: ${passed}/${total} passed`
          );
        } catch (error) {
          console.error("Animation test execution failed:", error);
          addChatMessage("system", "Animation test execution failed: " + error.message);
        }
      }

      async function runWebInterfaceTests() {
        if (!window.WebInterfaceTestSuite) {
          addChatMessage("system", "Web interface test suite not available");
          return;
        }

        addChatMessage("system", "Running web interface tests...");

        try {
          const testSuite = new WebInterfaceTestSuite();
          const results = await testSuite.runAllTests();

          const passed = results.filter((r) => r.passed).length;
          const total = results.length;

          addChatMessage(
            "system",
            `Interface tests completed: ${passed}/${total} passed`
          );
          
          // Show detailed results in console
          console.log("Detailed test results:", results);
          
        } catch (error) {
          console.error("Web interface test execution failed:", error);
          addChatMessage("system", "Interface test execution failed: " + error.message);
        }
      }

      function resetAnimation() {
        if (animationController) {
          animationController.resetContext();
          addChatMessage("system", "Animation context reset");
        }

        if (live2dIntegration) {
          live2dIntegration.triggerAnimation("neutral", 0.5, 1.0);
        }
      }

      // Simulate AI response for testing
      function simulateAIResponse(text, sentiment = null) {
        const responseData = {
          text: text,
          sentiment: sentiment,
          confidence: 0.8,
        };

        document.dispatchEvent(
          new CustomEvent("aiResponseReceived", {
            detail: responseData,
          })
        );

        if (animationController) {
          animationController.handleAIResponse(responseData);
        }
      }

      // Add some test buttons for development
      function addTestControls() {
        const testSection = document.createElement("div");
        testSection.className = "control-section";
        testSection.innerHTML = `
                <h3>Test Controls</h3>
                <button class="button" onclick="simulateAIResponse('Hello! I am so happy to see you!', 'happy')">Test Happy Response</button>
                <button class="button" onclick="simulateAIResponse('I am feeling quite sad today...', 'sad')">Test Sad Response</button>
                <button class="button" onclick="simulateAIResponse('What?! That is incredible!', 'surprised')">Test Surprised Response</button>
            `;

        document.querySelector(".control-panel").appendChild(testSection);
      }

      // WebSocket-related functions
      function updateWebSocketStatus(message, className) {
        const wsStatus = document.getElementById("websocket-status");
        if (wsStatus) {
          wsStatus.textContent = message;
          wsStatus.className = "status " + (className || "");
        }

        const wsInfo = document.getElementById("websocket-info");
        if (wsInfo) {
          wsInfo.textContent = `WebSocket: ${message}`;
        }
      }

      function updateServerStatus(serverData) {
        const serverInfo = document.getElementById("server-info");
        if (serverInfo && serverData) {
          const queueLength = serverData.queue_length || 0;
          const currentAnim = serverData.current_animation || "None";
          serverInfo.textContent = `Server: Queue(${queueLength}) Current(${currentAnim})`;
        }
      }

      function reconnectWebSocket() {
        if (websocketClient) {
          addChatMessage("system", "Reconnecting WebSocket...");
          websocketClient.reconnect();
        }
      }

      async function testTTSSync() {
        if (!websocketClient) {
          addChatMessage("system", "WebSocket client not available");
          return;
        }

        const testText =
          "Hello! This is a test of TTS synchronization with real-time animation.";
        addChatMessage("system", "Testing TTS synchronization...");

        try {
          const success = websocketClient.requestTTSSync(testText, "speak");
          if (success) {
            addChatMessage("system", "TTS sync request sent");
          } else {
            addChatMessage("system", "TTS sync request failed");
          }
        } catch (error) {
          addChatMessage("system", "TTS sync error: " + error.message);
        }
      }

      async function testMouthSyncRealtime() {
        if (!websocketClient) {
          addChatMessage("system", "WebSocket client not available");
          return;
        }

        addChatMessage("system", "Testing real-time mouth sync...");

        try {
          // Start mouth sync
          const success = websocketClient.sendMessage({
            type: "request_mouth_sync",
            data: {
              action: "start",
              duration: 3.0,
            },
          });

          if (success) {
            addChatMessage("system", "Mouth sync started");

            // Simulate audio levels for 3 seconds
            let frameCount = 0;
            const maxFrames = 30; // 3 seconds at 10 FPS

            const updateInterval = setInterval(() => {
              if (frameCount >= maxFrames) {
                clearInterval(updateInterval);

                // Stop mouth sync
                websocketClient.sendMessage({
                  type: "request_mouth_sync",
                  data: { action: "stop" },
                });

                addChatMessage("system", "Mouth sync test completed");
                return;
              }

              // Generate simulated audio data
              const time = frameCount / 10.0;
              const audioLevel = 0.3 + 0.5 * Math.abs(Math.sin(time * 3.0));
              const frequencyData = Array.from(
                { length: 8 },
                (_, i) => 0.1 + 0.3 * Math.abs(Math.sin(time * 2.0 + i))
              );

              websocketClient.sendMessage({
                type: "request_mouth_sync",
                data: {
                  action: "update",
                  audio_level: audioLevel,
                  frequency_data: frequencyData,
                },
              });

              frameCount++;
            }, 100); // 10 FPS
          } else {
            addChatMessage("system", "Mouth sync request failed");
          }
        } catch (error) {
          addChatMessage("system", "Mouth sync error: " + error.message);
        }
      }

      async function testAnimationQueue() {
        if (!websocketClient) {
          addChatMessage("system", "WebSocket client not available");
          return;
        }

        addChatMessage("system", "Testing animation queue...");

        const animations = [
          { expression: "happy", priority: "normal" },
          { expression: "surprised", priority: "high" },
          { expression: "sad", priority: "low" },
          { expression: "angry", priority: "critical" },
          { expression: "neutral", priority: "normal" },
        ];

        for (const anim of animations) {
          const success = websocketClient.requestAnimation(
            anim.expression,
            0.7,
            1.5,
            anim.priority
          );

          if (success) {
            addChatMessage(
              "system",
              `Queued: ${anim.expression} (${anim.priority})`
            );
          } else {
            addChatMessage("system", `Failed to queue: ${anim.expression}`);
          }

          // Small delay between requests
          await new Promise((resolve) => setTimeout(resolve, 200));
        }
      }

      async function requestServerAnimation() {
        if (!websocketClient) {
          addChatMessage("system", "WebSocket client not available");
          return;
        }

        const expressions = ["happy", "sad", "surprised", "angry", "neutral"];
        const randomExpression =
          expressions[Math.floor(Math.random() * expressions.length)];

        const success = websocketClient.requestAnimation(
          randomExpression,
          0.8,
          2.0,
          "normal"
        );

        if (success) {
          addChatMessage(
            "system",
            `Requested server animation: ${randomExpression}`
          );
        } else {
          addChatMessage("system", "Server animation request failed");
        }
      }

      function getWebSocketConnectionStatus() {
        if (!websocketClient) return null;

        const status = websocketClient.getConnectionStatus();
        addChatMessage(
          "system",
          `WebSocket Status: ${JSON.stringify(status, null, 2)}`
        );
        return status;
      }

      // Add test controls in development mode
      if (
        window.location.hostname === "localhost" ||
        window.location.search.includes("debug=true")
      ) {
        document.addEventListener("DOMContentLoaded", () => {
          setTimeout(addTestControls, 1000);
        });
      }
    </script>
  </body>
</html>
